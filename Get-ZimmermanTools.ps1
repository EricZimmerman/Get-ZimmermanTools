<#
	.SYNOPSIS
		This script will discover and download all available programs from https://ericzimmerman.github.io and download them to $Dest. By default, ONLY .net 9 builds are downloaded.
	
	.DESCRIPTION
		A file will also be created in $Dest that tracks the signature of each file, so rerunning the script will only download new versions. To redownload, remove lines from or delete the CSV file created under $Dest and rerun.
	
	.PARAMETER Dest
		The path you want to save the programs to.
	
	.PARAMETER NetVersion
		Which .net version to get. Default is ONLY net 9 builds as of 2025-05-18. Specify 4 or 9 to only get tools built against that version of .net, or 0 for all.
	
	.PARAMETER Proxy
		Specifies a proxy server for the request, rather than connecting directly to the Internet resource. Enter the URI of a network proxy server.
		Which version of .net build to get
	
	.PARAMETER ProxyCredential
		This parameter is valid only when the Proxy parameter is also used in the command. You cannot use the ProxyCredential and ProxyUseDefaultCredentials parameters in the same command.
		Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet.
		Specifies a user account that has permission to use the proxy server that is specified by the Proxy parameter.
	
	.PARAMETER ProxyUseDefaultCredentials
		This parameter is valid only when the Proxy parameter is also used in the command. You cannot use the ProxyCredential and ProxyUseDefaultCredentials parameters in the same command.
		Indicates that the cmdlet uses the credentials of the current user to access the proxy server that is specified by the Proxy parameter.
	
	.PARAMETER Sync
		A switch to tell Get-ZimmermanTools to run the --sync command for each of EvtxECmd, SQLECmd, and RECmd
	
	.EXAMPLE
		C:\PS> Get-ZimmermanTools.ps1 -Dest c:\tools
		Downloads/extracts and saves details about programs to c:\tools directory.
	
	.NOTES
		Author: Eric Zimmerman
		Date:   January 22, 2022
#>
[CmdletBinding(DefaultParameterSetName = 'NoProxy')]
param
(
	[Alias('d')]
	[string]$Dest = (Resolve-Path "."),
	[ValidateSet('0', '4', '9')]
	[Alias('nv')]
	[int]$NetVersion = (9),
	[Parameter(ParameterSetName = 'ProxyAlone',
			   Mandatory = $true)]
	[Parameter(ParameterSetName = 'ProxyWithCreds',
			   Mandatory = $true)]
	[Parameter(ParameterSetName = 'ProxyDefaultCreds',
			   Mandatory = $true)]
	[Alias('p')]
	[string]$Proxy,
	[Parameter(ParameterSetName = 'ProxyWithCreds',
			   Mandatory = $true)]
	[Alias('pc')]
	[pscredential]$ProxyCredential,
	[Parameter(ParameterSetName = 'ProxyDefaultCreds',
			   Mandatory = $true)]
	[Alias('pdc')]
	[switch]$ProxyUseDefaultCredentials,
	[Alias('s')]
	[switch]$Sync
)


function Write-Color
{
    <#
    .SYNOPSIS
    Write-Color is a wrapper around Write-Host delivering a lot of additional features for easier color options.

    .DESCRIPTION
    Write-Color is a wrapper around Write-Host delivering a lot of additional features for easier color options.

    It provides:
    - Easy manipulation of colors,
    - Logging output to file (log)
    - Nice formatting options out of the box.
    - Ability to use aliases for parameters

    .PARAMETER Text
    Text to display on screen and write to log file if specified.
    Accepts an array of strings.

    .PARAMETER Color
    Color of the text. Accepts an array of colors. If more than one color is specified it will loop through colors for each string.
    If there are more strings than colors it will start from the beginning.
    Available colors are: Black, DarkBlue, DarkGreen, DarkCyan, DarkRed, DarkMagenta, DarkYellow, Gray, DarkGray, Blue, Green, Cyan, Red, Magenta, Yellow, White

    .PARAMETER BackGroundColor
    Color of the background. Accepts an array of colors. If more than one color is specified it will loop through colors for each string.
    If there are more strings than colors it will start from the beginning.
    Available colors are: Black, DarkBlue, DarkGreen, DarkCyan, DarkRed, DarkMagenta, DarkYellow, Gray, DarkGray, Blue, Green, Cyan, Red, Magenta, Yellow, White

    .PARAMETER StartTab
    Number of tabs to add before text. Default is 0.

    .PARAMETER LinesBefore
    Number of empty lines before text. Default is 0.

    .PARAMETER LinesAfter
    Number of empty lines after text. Default is 0.

    .PARAMETER StartSpaces
    Number of spaces to add before text. Default is 0.

    .PARAMETER LogFile
    Path to log file. If not specified no log file will be created.

    .PARAMETER DateTimeFormat
    Custom date and time format string. Default is yyyy-MM-dd HH:mm:ss

    .PARAMETER LogTime
    If set to $true it will add time to log file. Default is $true.

    .PARAMETER LogRetry
    Number of retries to write to log file, in case it can't write to it for some reason, before skipping. Default is 2.

    .PARAMETER Encoding
    Encoding of the log file. Default is Unicode.

    .PARAMETER ShowTime
    Switch to add time to console output. Default is not set.

    .PARAMETER NoNewLine
    Switch to not add new line at the end of the output. Default is not set.

    .PARAMETER NoConsoleOutput
    Switch to not output to console. Default all output goes to console.

    .EXAMPLE
    Write-Color -Text "Red ", "Green ", "Yellow " -Color Red,Green,Yellow

    .EXAMPLE
    Write-Color -Text "This is text in Green ",
                      "followed by red ",
                      "and then we have Magenta... ",
                      "isn't it fun? ",
                      "Here goes DarkCyan" -Color Green,Red,Magenta,White,DarkCyan

    .EXAMPLE
    Write-Color -Text "This is text in Green ",
                      "followed by red ",
                      "and then we have Magenta... ",
                      "isn't it fun? ",
                      "Here goes DarkCyan" -Color Green,Red,Magenta,White,DarkCyan -StartTab 3 -LinesBefore 1 -LinesAfter 1

    .EXAMPLE
    Write-Color "1. ", "Option 1" -Color Yellow, Green
    Write-Color "2. ", "Option 2" -Color Yellow, Green
    Write-Color "3. ", "Option 3" -Color Yellow, Green
    Write-Color "4. ", "Option 4" -Color Yellow, Green
    Write-Color "9. ", "Press 9 to exit" -Color Yellow, Gray -LinesBefore 1

    .EXAMPLE
    Write-Color -LinesBefore 2 -Text "This little ","message is ", "written to log ", "file as well." `
                -Color Yellow, White, Green, Red, Red -LogFile "C:\testing.txt" -TimeFormat "yyyy-MM-dd HH:mm:ss"
    Write-Color -Text "This can get ","handy if ", "want to display things, and log actions to file ", "at the same time." `
                -Color Yellow, White, Green, Red, Red -LogFile "C:\testing.txt"

    .EXAMPLE
    Write-Color -T "My text", " is ", "all colorful" -C Yellow, Red, Green -B Green, Green, Yellow
    Write-Color -t "my text" -c yellow -b green
    Write-Color -text "my text" -c red

    .EXAMPLE
    Write-Color -Text "Testuję czy się ładnie zapisze, czy będą problemy" -Encoding unicode -LogFile 'C:\temp\testinggg.txt' -Color Red -NoConsoleOutput

    .NOTES
    Understanding Custom date and time format strings: https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings
    Project support: https://github.com/EvotecIT/PSWriteColor
    Original idea: Josh (https://stackoverflow.com/users/81769/josh)

    #>
	[alias('Write-Colour')]
	[CmdletBinding()]
	param (
		[alias ('T')]
		[String[]]$Text,
		[alias ('C', 'ForegroundColor', 'FGC')]
		[ConsoleColor[]]$Color = [ConsoleColor]::White,
		[alias ('B', 'BGC')]
		[ConsoleColor[]]$BackGroundColor = $null,
		[alias ('Indent')]
		[int]$StartTab = 0,
		[int]$LinesBefore = 0,
		[int]$LinesAfter = 0,
		[int]$StartSpaces = 0,
		[alias ('L')]
		[string]$LogFile = '',
		[Alias('DateFormat', 'TimeFormat')]
		[string]$DateTimeFormat = 'yyyy-MM-dd HH:mm:ss',
		[alias ('LogTimeStamp')]
		[bool]$LogTime = $true,
		[int]$LogRetry = 2,
		[ValidateSet('unknown', 'string', 'unicode', 'bigendianunicode', 'utf8', 'utf7', 'utf32', 'ascii', 'default', 'oem')]
		[string]$Encoding = 'Unicode',
		[switch]$ShowTime,
		[switch]$NoNewLine,
		[alias('HideConsole')]
		[switch]$NoConsoleOutput
	)
	if (-not $NoConsoleOutput)
	{
		$DefaultColor = $Color[0]
		if ($null -ne $BackGroundColor -and $BackGroundColor.Count -ne $Color.Count)
		{
			Write-Error "Colors, BackGroundColors parameters count doesn't match. Terminated."
			return
		}
		if ($LinesBefore -ne 0) { for ($i = 0; $i -lt $LinesBefore; $i++) { Write-Host -Object "`n" -NoNewline } } # Add empty line before
		if ($StartTab -ne 0) { for ($i = 0; $i -lt $StartTab; $i++) { Write-Host -Object "`t" -NoNewline } } # Add TABS before text
		if ($StartSpaces -ne 0) { for ($i = 0; $i -lt $StartSpaces; $i++) { Write-Host -Object ' ' -NoNewline } } # Add SPACES before text
		if ($ShowTime) { Write-Host -Object "[$([datetime]::Now.ToString($DateTimeFormat))] " -NoNewline } # Add Time before output
		if ($Text.Count -ne 0)
		{
			if ($Color.Count -ge $Text.Count)
			{
				# the real deal coloring
				if ($null -eq $BackGroundColor)
				{
					for ($i = 0; $i -lt $Text.Length; $i++) { Write-Host -Object $Text[$i] -ForegroundColor $Color[$i] -NoNewline }
				}
				else
				{
					for ($i = 0; $i -lt $Text.Length; $i++) { Write-Host -Object $Text[$i] -ForegroundColor $Color[$i] -BackgroundColor $BackGroundColor[$i] -NoNewline }
				}
			}
			else
			{
				if ($null -eq $BackGroundColor)
				{
					for ($i = 0; $i -lt $Color.Length; $i++) { Write-Host -Object $Text[$i] -ForegroundColor $Color[$i] -NoNewline }
					for ($i = $Color.Length; $i -lt $Text.Length; $i++) { Write-Host -Object $Text[$i] -ForegroundColor $DefaultColor -NoNewline }
				}
				else
				{
					for ($i = 0; $i -lt $Color.Length; $i++) { Write-Host -Object $Text[$i] -ForegroundColor $Color[$i] -BackgroundColor $BackGroundColor[$i] -NoNewline }
					for ($i = $Color.Length; $i -lt $Text.Length; $i++) { Write-Host -Object $Text[$i] -ForegroundColor $DefaultColor -BackgroundColor $BackGroundColor[0] -NoNewline }
				}
			}
		}
		if ($NoNewLine -eq $true) { Write-Host -NoNewline }
		else { Write-Host } # Support for no new line
		if ($LinesAfter -ne 0) { for ($i = 0; $i -lt $LinesAfter; $i++) { Write-Host -Object "`n" -NoNewline } } # Add empty line after
	}
	if ($Text.Count -and $LogFile)
	{
		# Save to file
		$TextToFile = ""
		for ($i = 0; $i -lt $Text.Length; $i++)
		{
			$TextToFile += $Text[$i]
		}
		$Saved = $false
		$Retry = 0
		Do
		{
			$Retry++
			try
			{
				if ($LogTime)
				{
					"[$([datetime]::Now.ToString($DateTimeFormat))] $TextToFile" | Out-File -FilePath $LogFile -Encoding $Encoding -Append -ErrorAction Stop -WhatIf:$false
				}
				else
				{
					"$TextToFile" | Out-File -FilePath $LogFile -Encoding $Encoding -Append -ErrorAction Stop -WhatIf:$false
				}
				$Saved = $true
			}
			catch
			{
				if ($Saved -eq $false -and $Retry -eq $LogRetry)
				{
					Write-Warning "Write-Color - Couldn't write to log file $($_.Exception.Message). Tried ($Retry/$LogRetry))"
				}
				else
				{
					Write-Warning "Write-Color - Couldn't write to log file $($_.Exception.Message). Retrying... ($Retry/$LogRetry)"
				}
			}
		}
		Until ($Saved -eq $true -or $Retry -ge $LogRetry)
	}
}

#Setup proxy information for Invoke-WebRequest
[hashtable]$IWRProxyConfig = @{ }

if ($Proxy)
{
	$IWRProxyConfig.Add("Proxy", $Proxy)
}
if ($ProxyCredential)
{
	$IWRProxyConfig.Add("ProxyCredential", $ProxyCredential)
}
if ($ProxyUseDefaultCredentials)
{
	$IWRProxyConfig.Add("ProxyUseDefaultCredentials", $true)
}


Write-Color -LinesBefore 1 "This script will discover and download all available programs" -BackgroundColor Blue
Write-Color "from https://ericzimmerman.github.io and download them to $Dest" -BackgroundColor Blue -LinesAfter 1
Write-Color "A file will also be created in $Dest that tracks the signature of each file,"
Write-Color "so rerunning the script will only download new versions."
Write-Color -LinesBefore 1 -Text "To redownload, remove lines from or delete the CSV file created under $Dest and rerun. Enjoy!"

Write-Color -LinesBefore 1 -Text "Use -NetVersion to control which version of the software you get (4 or 9). Default is 9. Use 0 to get all" -LinesAfter 1 -BackgroundColor Green

$TestColor = (Get-Host).ui.rawui.ForegroundColor
if ($TestColor -eq -1 -or $null -eq $TestColor)
{
	$defaultColor = [ConsoleColor]::Gray
}
else
{
	$defaultColor = $TestColor
}

$newInstall = $false

if (!(Test-Path -Path $Dest))
{
	Write-Color -Text "* ", "$Dest does not exist. Creating..." -Color Green, $defaultColor
	New-Item -ItemType directory -Path $Dest > $null
	
	$newInstall = $true
}

$URL = "https://raw.githubusercontent.com/EricZimmerman/ericzimmerman.github.io/master/index.md"

$WebKeyCollection = @()

$localDetailsFile = Join-Path $Dest -ChildPath "!!!RemoteFileDetails.csv"

if (Test-Path -Path $localDetailsFile)
{
	Write-Color -Text "* ", "Loading local details from '$Dest'..." -Color Green, $defaultColor
	$LocalKeyCollection = Import-Csv -Path $localDetailsFile
}

$toDownload = @()

#Get zips
$progressPreference = 'silentlyContinue'
$PageContent = (Invoke-WebRequest @IWRProxyConfig -Uri $URL -UseBasicParsing).Content
$progressPreference = 'Continue'

$regex = [regex] '(?i)\b(https)://[-A-Z0-9+&@#/%?=~_|$!:,.;]*[A-Z0-9+&@#/%=~_|$].(zip|txt)'
$matchdetails = $regex.Match($PageContent)


$uniqueUrlhash = @{ }


Write-Color -Text "* ", "Getting available programs..." -Color Green, $defaultColor
$progressPreference = 'silentlyContinue'
while ($matchdetails.Success)
{
	$newUrl = $matchdetails.Value.Replace('https://f001.backblazeb2.com/file/EricZimmermanTools/', 'https://download.ericzimmermanstools.com/')
	
	if ($newUrl.EndsWith('All.zip'))
	{
		$matchdetails = $matchdetails.NextMatch()
		continue
	}
		
	if ($newUrl.EndsWith('All_9.zip'))
	{
		$matchdetails = $matchdetails.NextMatch()
		continue
	}
	
	if ($uniqueUrlhash.Contains($newUrl))
	{
		$matchdetails = $matchdetails.NextMatch()
		continue
	}
	
	#Write-Host $newUrl
	
	$uniqueUrlhash.Add($newUrl, $newUrl)
		
	$isnet9 = $false
	
	if ($NetVersion -eq 4)
	{
		if (!$newUrl.EndsWith("Get-ZimmermanTools.zip") -and $newUrl.Contains('/net9/'))
		{
			$matchdetails = $matchdetails.NextMatch()
			continue
		}
	}
	
	if ($NetVersion -eq 9)
	{
		if (!$newUrl.EndsWith("Get-ZimmermanTools.zip") -and !$newUrl.Contains('/net9/'))
		{
			$matchdetails = $matchdetails.NextMatch()
			continue
		}
	}
	
	$isnet9 = $newUrl.Contains('/net9/')
	
	#Write-Host $newUrl
	
	$headers = $null
	try
	{
		$response = Invoke-WebRequest @IWRProxyConfig -Uri $newUrl -UseBasicParsing -Method Head -ErrorAction Stop
		$headers = $response.Headers
	}
	catch
	{
		if ($_.Exception.Response -ne $null)
		{
			$statusCode = $_.Exception.Response.StatusCode.value__
			Write-Color -Text "* ", "HTTP error $statusCode for URL: $newUrl" -Color Yellow, Red
			continue
		}
		else
		{
			Write-Color -Text "* ", "Network or connection error for URL: $newUrl. Error: $_" -Color Yellow, Red
			continue
		}
	}
	
	#Write-Host $headers
	
	#Check if net version is set and act accordingly
	#https://f001.backblazeb2.com/file/EricZimmermanTools/AmcacheParser.zip
	#https://f001.backblazeb2.com/file/EricZimmermanTools/net9/AmcacheParser_6.zip
	
	$newUrl = $matchdetails.Value.Replace('https://f001.backblazeb2.com/file/EricZimmermanTools', 'https://download.ericzimmermanstools.com/')
	
	#Write-Host 'THIS IS' + $newUrl
	
	$getUrl = $newUrl
	#$sha = $headers["x-bz-content-sha1"]
	$sha = $headers["ETag"]
	#$name = $headers["x-bz-file-name"]
	$name = ([uri]$getUrl).Segments[-1]
	
	if ($isnet9)
	{
		$name = Split-Path $name -leaf
	}
	
	$size = $headers["Content-Length"]
	
	$details = @{
		Name = [string]$name
		SHA1 = [string]$sha
		URL  = [string]$getUrl
		Size = [string]$size
		IsNet9 = [bool]$isnet9
	}
	
	$webKeyCollection += New-Object PSObject -Property $details
	
	$matchdetails = $matchdetails.NextMatch()
}
$progressPreference = 'Continue'

Foreach ($webKey in $webKeyCollection)
{
	if ($newInstall)
	{
		$toDownload += $webKey
		continue
	}
	
	$localFile = $LocalKeyCollection | Where-Object { $_.URL -eq $webKey.URL }
	
	if ($null -eq $localFile -or $localFile.SHA1 -ne $webKey.SHA1)
	{
		#Needs to be downloaded since SHA is different or it doesnt exist
		$toDownload += $webKey
	}
}

if ($toDownload.Count -eq 0)
{
	Write-Color -LinesBefore 1 -Text "* ", "All files current. Exiting." -Color Green, Blue -LinesAfter 1
	return
}



$downloadedOK = @()

$destFile = ""
$name = ""

$i = 0
$dlCount = $toDownload.Count
Write-Color -Text "* ", "Files to download: $dlCount" -Color Green, $defaultColor
foreach ($td in $toDownload)
{
	$p = [math]::round(($i/$toDownload.Count) * 100, 2)
	
	#Write-Host ($td | Format-Table | Out-String)
	
	$tempDest = $Dest
	
	try
	{
		$dUrl = $td.URL
		$size = $td.Size -as [long]
		$name = $td.Name
		$is9 = $td.IsNet9
		
		if ($is9)
		{
			$tempDest = Join-Path $tempDest "net9"
			if (!(Test-Path -Path $tempDest))
			{
				Write-Color -Text "* ", "$tempDest does not exist. Creating..." -Color Green, $defaultColor
				New-Item -ItemType directory -Path $tempDest > $null
			}
		}
		
		Write-Progress -Activity "Updating programs...." -Status "$p% Complete" -PercentComplete $p -CurrentOperation "Downloading $name"
		$destFile = [IO.Path]::Combine($tempDest, $name)
		
		$progressPreference = 'silentlyContinue'
		Invoke-WebRequest @IWRProxyConfig -Uri $dUrl -OutFile $destFile -ErrorAction:Stop -UseBasicParsing
		
		$extraInfo = ""
		if ($is9)
		{
			$extraInfo = " (net 9)"
		}
		
		$sizeNice = '{0:N0}' -f $size
		
		Write-Color -Text "* ", "Downloaded $name (Size: $sizeNice)", $extraInfo -Color Green, Blue, Red
		
		if ($name.endswith("zip"))
		{
			
			Microsoft.PowerShell.Archive\Expand-Archive -Path $destFile -DestinationPath $tempDest -Force
		}
		
		$downloadedOK += $td
	}
	catch
	{
		$ErrorMessage = $_.Exception.Message
		Write-Color -Text "* ", "Error downloading $name ($ErrorMessage). Wait for the run to finish and try again by repeating the command" -Color Green, Red
	}
	finally
	{
		$progressPreference = 'Continue'
		if ($name.endswith("zip") -and (Test-Path -Path $destFile))
		{
			remove-item -Path $destFile -Force
		}
		
	}
	$i += 1
}

#Write-Host ($webKeyCollection | Format-Table | Out-String)

#Downloaded ok contains new stuff, but we need to account for existing stuff too
foreach ($webItems in $webKeyCollection)
{
	#Check what we have locally to see if it also contains what is in the web collection
	$localFile = $LocalKeyCollection | Where-Object { $_.SHA1 -eq $webItems.SHA1 }
	
	#if its not null, we have a local file match against what is on the website, so its ok
	
	if ($null -ne $localFile)
	{
		#consider it downloaded since SHAs match
		$downloadedOK += $webItems
	}
}

Write-Color -LinesBefore 1 -Text "* ", "Saving downloaded version information to $localDetailsFile" -Color Green, $defaultColor -LinesAfter 1

$downloadedOK | export-csv -Path $localDetailsFile

#We need to sync the Maps for EvtxECmd and SQLECmd, and the batch files for RECmd
#Reference: https://www.youtube.com/watch?v=mIb1GQP3ciE

if ($Sync)
{
	Write-Color -Text "* ", "Sync switch detected! Syncing all ancillary files for EvtxECmd, SQLECmd, and RECmd..." -Color Green, $defaultColor
	Write-Color -Text "* ", "Looking for any and all instances of EvtxECmd, RECmd, and SQLECmd in $Dest..." -Color Green, $defaultColor
	Get-ChildItem -Path $Dest -Filter "*ecmd.exe" -Recurse | Where-Object { $_.Name -in "evtxecmd.exe", "sqlecmd.exe", "recmd.exe" } | ForEach-Object {
		Write-Host "Running: $($_.FullName)"
		try
		{
			
			Write-Color -Text "* ", "Syncing $($_.FullName)..." -Color Green, $defaultColor
			& $_.FullName --sync
		}
		catch
		{
			Write-Color -Text "* ", "Error syncing $($_.FullName)" -Color Red, $defaultColor
		}
	}
}
